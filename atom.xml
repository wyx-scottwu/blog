<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott Wu</title>
  
  
  <link href="https://blog.scottwu.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.scottwu.cn/"/>
  <updated>2022-09-22T14:10:38.432Z</updated>
  <id>https://blog.scottwu.cn/</id>
  
  <author>
    <name>Scott Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器API</title>
    <link href="https://blog.scottwu.cn/2022/09/21/0730day05/"/>
    <id>https://blog.scottwu.cn/2022/09/21/0730day05/</id>
    <published>2022-09-21T13:56:14.000Z</published>
    <updated>2022-09-22T14:10:38.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a><code>Content</code></h2><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Content&quot;&gt;&lt;a href=&quot;#Content&quot; class=&quot;headerlink&quot; title=&quot;Content&quot;&gt;&lt;/a&gt;&lt;code&gt;Content&lt;/code&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;h6 id=&quot;以上描述及解决方案均属个人观点，若您存在任何疑问及意见</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>JS模块化</title>
    <link href="https://blog.scottwu.cn/2022/09/13/0730day04/"/>
    <id>https://blog.scottwu.cn/2022/09/13/0730day04/</id>
    <published>2022-09-13T14:38:16.000Z</published>
    <updated>2022-09-13T14:53:05.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="script-标签-async-和-defer-属性"><a href="#script-标签-async-和-defer-属性" class="headerlink" title="script 标签 async 和 defer 属性"></a><code>script</code> 标签 <code>async</code> 和 <code>defer</code> 属性</h2><p>  <code>defer</code> 与 <code>async</code> 均是异步下载脚本，不同点在于解析执行的时机不同，<code>defer</code> 较为“温柔“，会排队等待 <code>GUI</code> 线程执行完成后再去执行 <code>js</code> 脚本；而 <code>async</code> 则是在其下载完后便直接解析执行，一毫秒都不会多等。 </p><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;script-标签-async-和-defer-属性&quot;&gt;&lt;a href=&quot;#script-标签-async-和-defer-属性&quot; class=&quot;headerlink&quot; title=&quot;script 标签 async 和 defer 属性&quot;&gt;&lt;/a&gt;&lt;code&gt;sc</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://blog.scottwu.cn/2022/09/04/0730day03/"/>
    <id>https://blog.scottwu.cn/2022/09/04/0730day03/</id>
    <published>2022-09-04T05:27:59.000Z</published>
    <updated>2022-09-04T07:53:51.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><code>概念</code></h2><ul><li>宏任务 - <code>tasks</code><blockquote><p>一个 任务 就是由执行诸如从头执行一段程序、执行一个事件回调或一个 interval/timeout 被触发之类的标准机制而被调度的任意 JavaScript 代码。这些都在 <strong>任务队列（task queue）</strong> 上被调度。<sup><a href="#tasks-&-microtasks-of-mdn">[1]</a></sup></p></blockquote></li><li>微任务 - <code>microtasks</code><blockquote><p>两个 <code>tasks</code> 之间执行的任务。</p></blockquote></li></ul><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noopener">Tasks &amp; microtasks</a> <span id="tasks-&-microtasks-of-mdn"></span></p><p>[2]. <a href="https://www.jb51.net/article/256204.htm" target="_blank" rel="noopener">JS前端宏任务微任务及Event Loop使用详解</a> <span id="taks-&-eventloop"></span></p><p>[*]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;code&gt;概念&lt;/code&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宏任务 - &lt;code&gt;tasks&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;一个 任务 就是由执行</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>0730day11</title>
    <link href="https://blog.scottwu.cn/2022/09/03/0730day11/"/>
    <id>https://blog.scottwu.cn/2022/09/03/0730day11/</id>
    <published>2022-09-03T12:00:56.000Z</published>
    <updated>2022-09-04T05:39:13.767Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h6 id=&quot;以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。&quot;&gt;&lt;a href=&quot;#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。&quot; class=&quot;headerlink&quot; title=&quot;以上描述及</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>OOP/protoType</title>
    <link href="https://blog.scottwu.cn/2022/08/18/0730day02/"/>
    <id>https://blog.scottwu.cn/2022/08/18/0730day02/</id>
    <published>2022-08-18T13:45:09.000Z</published>
    <updated>2022-09-04T05:38:40.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a><code>Content</code></h2><h3 id="为什么要面向对象"><a href="#为什么要面向对象" class="headerlink" title="为什么要面向对象"></a>为什么要面向对象</h3><h3 id="JS对象创建方法"><a href="#JS对象创建方法" class="headerlink" title="JS对象创建方法"></a><code>JS对象创建方法</code></h3><ul><li><code>Object.create</code> —— 根据参数创建以参数为原型的对象<sup><a href="#Object-create-of-mdn">[1]</a></sup></li><li>直接声明对象: <code>var const let</code></li><li><code>new</code> 关键字</li></ul><h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a><code>new</code> 关键字</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cosnt p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. p 的构造函数时 Person</span></span><br><span class="line"><span class="comment"> *  .1 new 创建一个对象，指向构造函数的原型</span></span><br><span class="line"><span class="comment"> *    - p.__proto__ === Person.protoType</span></span><br><span class="line"><span class="comment"> *  .2 构造函数上，有个原型（是个对象），里面有个 constructor 函数，就是这个构造函数本身</span></span><br><span class="line"><span class="comment"> *    - Person.prototype.constructor === Person</span></span><br><span class="line"><span class="comment"> *  .3 p 对象的构造函数是 Person</span></span><br><span class="line"><span class="comment"> *    - p.constructor === Person</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><p><code>new</code> 关键字做了什么<sup><a href="#what-the-new-keyword-does-of-mdn">[2]</a></sup></p><ul><li>创建空对象 —— <code>newInstance</code></li><li>将 <code>newInstance</code> 的 <code>__proto__</code> 属性指向其构造函数原型属性 <code>prototype</code></li><li>将创建的对象作为 <code>this</code> // mdn中这么描述到：将步骤 1 新创建的对象作为<strong>this</strong>的上下文，个人理解这部分含义是将执行的构造函数的this绑定为 <code>newInstance</code></li><li><ul><li>存在返回值且为对象，则创建结果为返回对象</li></ul></li><li><ul><li>否则为创建的对象  </li></ul></li></ul><h4 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 <code>new</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_new</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">typeof</span> <span class="keyword">constructor</span> === 'function') &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'constructor must be a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line"></span><br><span class="line">  const res = <span class="keyword">constructor</span>.apply(obj, args);</span><br><span class="line"></span><br><span class="line">  if(res instanceof Object) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>实现继承，其核心可以概括为以下两部分</p><ol><li>使用父类的构造函数方法和原型函数</li><li>让对象的原型链指向父类</li></ol><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a> <span id="Object-create-of-mdn"></span></p><p>[2]. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#:~:text=called%20without%20arguments.-,Description,-When%20a%20function" target="_blank" rel="noopener">What the new keyword does</a> <span id="what-the-new-keyword-does-of-mdn"></span></p><p>[*]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Content&quot;&gt;&lt;a href=&quot;#Content&quot; class=&quot;headerlink&quot; title=&quot;Content&quot;&gt;&lt;/a&gt;&lt;code&gt;Content&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;为什么要面向对象&quot;&gt;&lt;a href=&quot;#为什么要面向对象&quot; cl</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>this指针/闭包/作用域</title>
    <link href="https://blog.scottwu.cn/2022/08/14/0730day01/"/>
    <id>https://blog.scottwu.cn/2022/08/14/0730day01/</id>
    <published>2022-08-14T06:06:33.000Z</published>
    <updated>2022-08-18T13:44:00.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p><strong>JIT</strong><br>—— <code>Just in time</code> 运行时编译。。。</p><p><strong>非表达式函数</strong><sup><a href="#Expressions-of-mdn">[1]</a></sup><br>—— 即非直接通过 <code>function</code> 语法直接定义而成的的函数</p><p><strong>变量提升</strong> <code>let</code> <code>const</code> 可能存在，但没有纠结的意义，<code>Chrome</code> 浏览器 <code>debugger</code> 可见得变量被提升<br><img src="http://tva1.sinaimg.cn/large/006rt2YXly1h56c9cn1y2j3067083751.jpg" alt="let, const变量提升"></p><p>LHS<br>—— 赋值操作左侧 left</p><p>RHS<br>—— 赋值操作右侧 right</p><p>词法作用域<br>—— 代码里的作用域</p><p>IIFE<br>—— 立即执行函数</p></blockquote><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a><code>Content</code></h2><p><code>this</code> 的指向，是根据上下文动态决定的。</p><ul><li>在简单调用时，<code>this</code> 默认指向 <code>window (Explorer)</code>, <code>global (NodeJS)</code>, <code>undefined (Strict Mode)</code></li><li>对象调用时，绑定在对象上</li><li>使用 <code>call</code>, <code>apply</code>, <code>bind</code> 时，绑定在指定参数上</li><li>使用 <code>new</code> 时，绑定到新创建对象上</li><li><ul><li>以上部分优先级：new &gt; call/apply/bind &gt; 对象调用</li></ul></li><li>箭头函数 <code>this</code>, 根据外围规则决定</li></ul><p><code>IIFE</code> 立即执行，代码执行到其部位时会立即执行，如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iifeObj = &#123;</span><br><span class="line">  fn: <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'iifeObj'</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125; <span class="comment">// 对象 iifeObj 执行到声明后便会立即执行 自执行函数，而 fn为自执行函数返回结果</span></span><br></pre></td></tr></table></figure><h2 id="手写-call"><a href="#手写-call" class="headerlink" title="手写 call"></a>手写 <code>call</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.handWritingCall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [callThis,...args] = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  callThis.__fn = fn;</span><br><span class="line">  <span class="keyword">const</span> res = callThis.__fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> callThis.__fn;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">JavaScript 表达式定义</a> <span id="Expressions-of-mdn"></span></p><p>[2]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JIT&lt;/strong&gt;&lt;br&gt;—— &lt;code&gt;Just in time&lt;/code&gt; 运行时编</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>es6/generator</title>
    <link href="https://blog.scottwu.cn/2022/06/14/es6-generator/"/>
    <id>https://blog.scottwu.cn/2022/06/14/es6-generator/</id>
    <published>2022-06-14T14:33:55.000Z</published>
    <updated>2022-09-04T05:35:26.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="es6-generator"><a href="#es6-generator" class="headerlink" title="es6-generator"></a><strong>es6-generator</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>  &emsp;&emsp;在各路文档中，了解到 <code>Generator</code> 是一个生成器，目的是为了生成一个 <code>Iterator</code> – <code>&quot;迭代器&quot;</code>，用以进行流程控制，让代码在你需要停止的地方提下来，并能够在下次流程进行的时候在上次停止的地方开始。</p><p>  &emsp;&emsp;其中有几个重要的名次及其概念列举如下：</p><ul><li><p><code>Generator</code> 其译为生成器，目的是为了通过其创建一个迭代器，声明方法如下👇；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>*</code> 的位置并没有强制限制，只要保证在 <code>function</code> 与生成器名称之间就可以了。</p></li><li><p><code>next()</code> 为获取迭代器执行结果的方法，主要用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gf = generatorFun();</span><br><span class="line">gf.next();  <span class="comment">// &#123; value:1, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>  需要注意的是，直接调用 <code>generatorFun</code>，并不能像常规函数那样直接获取函数执行结果，而是获得了一个迭代器 <code>Iterator</code>，在找到的一些文章中，大多愿意称其为指向函数内部状态的 <code>指针对象</code>，当调用迭代器对象内的 <code>next</code> 方法时，其指针便会从函数头部或上一次停下来的地方继续执行；</p></li><li><p><code>yield</code> 其译为产出，产出的是其后面的表达式的运行结果，然后在 <code>yield</code> 处暂停执行，直到下次调用 <code>next</code> 方法触发才会在停止处继续执行，且当 <code>yield</code> 用在表达式中时，需要放在圆括号里，如下，：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="string">'world'</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="string">'world'</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h2><p>  &emsp;&emsp;从上述描述中基本可以了解到 <code>Generator</code> 的基本用法如下👇图所示。</p><p>  <img src="/images/generator.png" alt="Generator 基本用法流程图"></p><p>  &emsp;&emsp;其中有这么几个需要注意的点<sup><a href="#flowchat-diff">[1]</a></sup>：</p><ul><li><p>如上图中的代码，即使只有一个 <code>yield</code>，当第一次调用 <code>gf.next()</code> 也并没有直接到 <code>done</code> 的状态，这其实比较好理解，因为第一次的 <code>next</code> 并没有使代码运行到函数尾部，而是停留在了 <code>yield</code> 上，尽管 <code>yield</code> 之后再无可执行代码；</p></li><li><p>生成器函数执行流程区别于普通函数，举个🌰：<br><img src="/images/flowchat-diff.png" alt="生成器函数与普通函数比较"><br>从上图可以看到，普通函数与生成器函数的执行顺序主要区别在于 <code>yield</code> 表达式使得每一次调用 <code>next</code> 最终都会将函数暂停在 <code>yield</code> 表达式或者函数尾部，直到下次调用 <code>next</code> 将从上一个 <code>yield</code> 运行到下一个 <code>yield</code> 或者函数尾部。</p></li><li><p>从上图的生成函数代码中会发现一个问题，就是最后的输出结果是 <code>NaN</code>，这其实是因为 <code>yield</code> 只负责<code>“产出”</code>导致的，也就是 <code>yield</code> 表达式并不能将它右侧的表达式运行结果返回到左侧，而如果需要上一步的结果，则可以借助 <code>next</code> 来进行传参，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. a"</span>, a) <span class="comment">// 2</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gf = generatorFun();</span><br><span class="line"><span class="keyword">const</span> a = gf.next();</span><br><span class="line">gf.next(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h2><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a><strong><code>for of</code></strong></h3><p>  &emsp;&emsp;<code>for of</code> 循环可以自动遍历 <code>Generator</code> 函数时生成的 <code>Iterator</code> 对象，且此时不再需要调用 <code>next</code> 方法。如下：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">for0f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' javascript'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> for0f())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. ~ v"</span>, v)</span><br><span class="line">&#125; <span class="comment">// 'hello', ' ', 'world'</span></span><br></pre></td></tr></table></figure><br>  &emsp;&emsp;通过观察输出结果，我们发现一个问题，就是最后的 <code>javascript</code> 并没有输出出来，这是因为 <code>for of</code> 循环在 <code>done === true</code> 时便中止掉了，并且不会返回当前结果，所以最后的 <code>return</code> 结果并没有获取到。</p><p>  &emsp;&emsp;除了 <code>for...of</code> 循环以外，扩展运算符（<code>...</code>）、解构赋值和 <code>Array.from</code><sup><a href="#array-from">[2]</a></sup> 方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <code>Generator</code> 函数返回的 <code>Iterator</code> 对象，作为参数。<sup><a href="#es6-generator-jianshu1">[3]</a></sup></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">for0f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'javascript'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> for0f()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'hello', ' ', 'world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...for0f()] <span class="comment">// ['hello', ' ', 'world]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z] = for0f();</span><br><span class="line">x <span class="comment">// 'hello'</span></span><br><span class="line">y <span class="comment">// ' '</span></span><br><span class="line">z <span class="comment">// 'world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(for0f()) <span class="comment">// ['hello', ' ', 'world]</span></span><br></pre></td></tr></table></figure><h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a><strong><code>Generator.prototype.throw()</code></strong></h3><p>  &emsp;&emsp;一个在生成器函数外部向函数体内部抛出错误的方法。</p><h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a><strong><code>Generator.prototype.return()</code></strong></h3><p>  &emsp;&emsp;一个在生成器函数外部向函数体内部 <code>return</code>，并终结遍历。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a><strong><code>yield*</code></strong></h3><p>  &emsp;&emsp;<code>yield*</code> 表达式用于委托给另一个 <code>generator</code> 或 <code>可迭代对象</code><sup><a href="#iterable-object">[4]</a></sup>。<sup><a href="#es6-yield*">[5]</a></sup></p><p>  &emsp;&emsp;<code>yield*</code> 有区别于 <code>yield</code>。<code>yield</code> 可以将其理解为暂停标识符，即在 <code>yield</code> 处开始或停止。而 <code>yield*</code> 则可以理解为展开一个可迭代对象进行迭代。举个🌰：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* gf2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>  &emsp;&emsp;上述代码其实可以看作等价于下面的代码<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  yield_return <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  &emsp;&emsp;只不过有一条需要注意的是 <code>yield_return</code> 是我为了方便理解自己定义的一个标识，实际上是没有这个东西的。之所以这么定义是因为 <code>yield*</code> 所委托的迭代对象 <code>return</code> 的 <code>value</code> 将作为返回值返回到 <code>yield*</code> 表达式上，再举个🌰：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> v = <span class="keyword">yield</span>* gf2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. ~ function*gf1 ~ v"</span>, v)  <span class="comment">// 🐛. ~ function*gf1 ~ v,3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://blog.csdn.net/weixin_39798049/article/details/87111633" target="_blank" rel="noopener">es 异步流程(二)之generator篇</a> <span id="flowchat-diff"></span></p><p>[2]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from</a> <span id="array-from"></span></p><p>[3]. <a href="https://www.jianshu.com/p/56000dcf7cfe" target="_blank" rel="noopener">ES6中的Generator函数</a> <span id="es6-generator-jianshu1"></span></p><p>[4]. <a href="https://juejin.cn/post/6873457657018728456" target="_blank" rel="noopener">JS 可迭代对象</a> <span id="iterable-object"></span></p><p>[5]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*" target="_blank" rel="noopener">yield*</a> <span id="es6-yield*"></span></p><p>[6]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;es6-generator&quot;&gt;&lt;a href=&quot;#es6-generator&quot; class=&quot;headerlink&quot; title=&quot;es6-generator&quot;&gt;&lt;/a&gt;&lt;strong&gt;es6-generator&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;</summary>
      
    
    
    
    
    <category term="ECMAScript" scheme="https://blog.scottwu.cn/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>http/cookies</title>
    <link href="https://blog.scottwu.cn/2022/06/07/http-cookies/"/>
    <id>https://blog.scottwu.cn/2022/06/07/http-cookies/</id>
    <published>2022-06-07T12:55:30.000Z</published>
    <updated>2022-08-14T06:01:53.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About-Cookies"><a href="#About-Cookies" class="headerlink" title="About Cookies"></a>About Cookies</h1><h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. <code>Cookie</code></h2><p>  &emsp;&emsp;一般来讲，由服务端创建并存储携带在 <code>http Response Headers</code> 的 <code>Set-Cookie</code> 中，并在浏览器下次请求同一服务器时，通过 <code>Request Headers</code> 的 <code>Cookie</code> 字段发送给后端。<br><br>  <code>Cookie</code> 是无状态http的<em>状态</em>。</p><p>  <img src="/images/cookies-circle.png" alt="cookie 流转图"></p><p>  <code>Cookie</code> 目前主流用法：</p><ul><li><p>会话状态管理；</p></li><li><p>个性化设置/推荐（广告投放）；</p></li><li><p>浏览器行为跟踪；</p><p>&emsp;&emsp;同时，不仅仅是只有服务端才可创建 <code>Cookie</code>，浏览器或者说客户端也可操作 <code>Cookie</code>，如：<code>document.cookie</code>。<span id="cookies-create-javascript"></span></p></li></ul><h2 id="2-Cookie-生命周期"><a href="#2-Cookie-生命周期" class="headerlink" title="2. Cookie 生命周期"></a>2. <code>Cookie</code> 生命周期</h2><p>  &emsp;&emsp;<code>Cookie</code> 的生命周期可以通过 <code>Expires</code> 或 <code>Max-Age</code> 来定义。</p><p>  &emsp;&emsp;有趣的是，经过我的测试发现无论是在前端（浏览器）上直接设置 <code>Expires/Max-Age</code> 还是经过 <code>Node</code> 服务器进行设置 <code>Expires/Max-Age</code> 其最终都会被计算成日期传到前端。</p><p>  &emsp;&emsp;也就是说，在前端可以看到或者说获取到的 <code>Cookie</code> 值其实只有两种，分别是 <code>Date()</code> 类型和 <code>Session</code> 。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">🥇 Date() 日期类型</span><br><span class="line">🥈 Session &#x2F;&#x2F; 仅在当前会话有效</span><br></pre></td></tr></table></figure><p>  &emsp;&emsp;关于 <code>Cookie</code> 过期验证，没什么好验证的，过期的 <code>Cookie</code> 就直接被浏览器删掉了，根本到不了后端。就算你手动添加一个，那也不是之前那个了，因为那就相当于又重新生效了一个同名 <code>Cookie</code> 而已。</p><h2 id="3-限制访问-Cookie"><a href="#3-限制访问-Cookie" class="headerlink" title="3. 限制访问 Cookie"></a>3. 限制访问 <code>Cookie</code></h2><p>  &emsp;&emsp;有两种方法可以确保 <code>Cookie</code> 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和 <code>HttpOnly</code> 属性<sup><a href="#cookies-of-mdn">[1]</a></sup>。</p><ul><li><code>Secure</code> 只能用在https协议上传输；</li><li><code>HttpOnly</code> 客户端通过 <code>document.cookie</code> 无法获取设置该属性的 <code>Cookie</code> 字段；</li></ul><h2 id="4-Cookie-作用域"><a href="#4-Cookie-作用域" class="headerlink" title="4. Cookie 作用域 "></a>4. <code>Cookie</code> 作用域 <span id="cookies-scope"></span></h2><p>  &emsp;&emsp;<code>Domain</code> 和 <code>Path</code> 标识定义了 <code>Cookie</code> 的作用域：即允许 <code>Cookie</code> 应该发送给哪些URL<sup><a href="#cookies-of-mdn">[1]</a></sup>。</p><ul><li><p><code>Domain</code>：<code>Cookie</code> 作用的域名，指定 <code>Domain</code> 时，作用的域名为指定域名及其子域名，若未指定，则默认为当前 <code>origin</code> 且不包含子域名；</p></li><li><p><code>Path</code>：总结为两句话。若设置了，则已设置的值为准，若未设置，则由 <code>URL</code> 的 <code>path</code> 的最后一个 <code>/</code> 向前截取，截取的结果作为 <code>Cookie</code> 的 <code>Path</code>。其作用域为当前 <code>path</code> 路径下的所有子路径，包含当前路径<sup><a href="#cookie-path-rules">[2]</a></sup>；</p></li></ul><h2 id="5-SameSite-属性"><a href="#5-SameSite-属性" class="headerlink" title="5. SameSite 属性"></a>5. <code>SameSite</code> 属性</h2><p>  &emsp;&emsp;<code>SameSite</code> 顾名思义——同一站点的配置项，理解来讲就是来限制 <code>Cookie</code> 传播是否受”同一站点—— <code>SameSite</code> “的限制。</p><p>  &emsp;&emsp;<code>MDN</code> 里这样描述：<code>SameSite Cookie</code> 允许服务器要求某个 <code>cookie</code> 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（<code>CSRF</code>）<sup><a href="#cookies-of-mdn">[1]</a></sup>。</p><p>  <code>SameSite</code> 共有下面三种值<sup><a href="#cookie-samesite-attrs">[3]</a></sup><sup><a href="#what-is-cookie-samesite">[4]</a></sup>：</p><ul><li><p><code>None</code>：就是没有限制，<code>Cookie</code> 想怎么传就怎么传；</p></li><li><p><code>Strict</code>：<code>Strict</code>（严格）模式，严格到只有当前 <code>top.window</code> 对象的 <code>url</code> 及其子 <code>url</code> 才有资格传播，但不代表一定会传播，因为还要满足 <a href="#cookies-scope"><code>Cookie</code> 作用域</a> 的限制；</p></li><li><p><code>Lax</code>：<code>Lax</code>（不严格）模式，即存在一些情况可以传播 <code>Cookie</code>；</p><p>具体情况见下图描述⬇️。<sup><a href="#cookie-samesite-conf">[5]</a></sup></p><p><img src="https://upload-images.jianshu.io/upload_images/19506176-0f3e256e10049c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1102/format/webp" alt="SameSite"></p></li></ul><h2 id="6-Cookie-prefixes"><a href="#6-Cookie-prefixes" class="headerlink" title="6. Cookie prefixes"></a>6. <code>Cookie prefixes</code></h2><p>  &emsp;&emsp;<code>Cookie prefixes</code> 指在 <code>Cookie</code> 名前添加绑定的前缀：<code>&quot;__Host-&quot;</code> 与 <code>&quot;__Secure-&quot;</code>。</p><ul><li><code>__Host-</code>：<code>MDN</code> 这么解释道：它需要设置 <code>Secure</code> 属性，并且来自安全的 <code>origin</code>，同时还要设置 <code>Path</code> 为 <code>/</code>，但 <code>Domain</code> 要为默认值，即只有在当前安全的 <code>host</code> 下才可传播发送该 <code>Cookie</code>, 同时 <code>MDN</code> 称之为 <code>domain-locked</code>, 我理解其为<code>&quot;被锁定的域&quot;</code>。</li><li><code>__Secure-</code>：相较于 <code>__Host-</code>，其仅要求来自安全的 <code>origin</code>，并设置 <code>Secure</code> 属性才可传播发送。</li></ul><h2 id="7-JavaScript-通过-Document-cookie-访问-Cookie"><a href="#7-JavaScript-通过-Document-cookie-访问-Cookie" class="headerlink" title="7. JavaScript 通过 Document.cookie 访问 Cookie"></a>7. <code>JavaScript</code> 通过 <code>Document.cookie</code> 访问 <code>Cookie</code></h2><p>  &emsp;&emsp;在<a href="#cookies-create-javascript">第一章节</a>中就已经剪短提到过通过 <code>JavaScript</code> 对 <code>Cookie</code> 进行操作的方法，但该方法仅可访问创建非 <code>HttpOnly</code> 标记的 <code>Cookie</code>。</p><h2 id="8-Cookie-安全"><a href="#8-Cookie-安全" class="headerlink" title="8. Cookie 安全"></a>8. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%AE%89%E5%85%A8" target="_blank" rel="noopener"><code>Cookie</code> 安全</a></h2><p>  &emsp;&emsp;凡事涉及安全的问题都不会是小问题。</p><p>  &emsp;&emsp;这里不太好概述，理解的也不深，直接贴链接吧</p><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP cookies of MDN</a> <span id="cookies-of-mdn"></span></p><p>[2]. <a href="https://www.jianshu.com/p/48556e5c44f5" target="_blank" rel="noopener">Cookie的path值的默认规则</a> <span id="cookie-path-rules"></span></p><p>[3]. <a href="https://www.youtube.com/watch?v=aUF2QCEudPo" target="_blank" rel="noopener">Cookie SameSite</a> <span id="cookie-samesite-attrs"></span></p><p>[4]. <a href="https://www.leixue.com/ask/what-is-samesite" target="_blank" rel="noopener">SameSite 是什么</a> <span id="what-is-cookie-samesite"></span></p><p>[5]. <a href="https://www.jianshu.com/p/dd73c27ab8d6" target="_blank" rel="noopener">Cookie中的SameSite设置</a> <span id="cookie-samesite-conf"></span></p><p>[6]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">Cookie 安全 of MDN</a> <span id="cookie-security-of-mdn"></span></p><p>[7]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
    <summary type="html">http-cookies 学习记录，顺序参考 MDN</summary>
    
    
    
    
    <category term="HTTP" scheme="https://blog.scottwu.cn/tags/HTTP/"/>
    
  </entry>
  
</feed>
